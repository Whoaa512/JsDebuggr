# Debuggify? JsDbgr? JsDebuggr? i dunno.
# v.5 first sorta working one

import sublime
import sublime_plugin
import uuid
import re

# TODO - scan file at startup for breakpoints
# TODO - save breakpoint sets per document and/or per set?
# TODO - make sure semicolons are placed correctly
# TODO - make breakpoint commands work only for javascript


class Debuggify(sublime_plugin.TextCommand):

    breakpoints = {}
    testRegion = sublime.Region(0, 0)

    def run(self, edit, **options):
        viewId = str(self.view.id())

        #if this view has not been registered yet, register it
        if not viewId in self.breakpoints:
            self.breakpoints[viewId] = {}

        if(options and "action" in options and options["action"] == "clearAll"):
            print("clearing all breaks")
            self.clear_all(edit)
        elif(options and "condition" in options):
            print("conditional breakpoint. condition is %s" % options["condition"])
            self.toggle_breakpoint(edit, options["condition"])
        elif(options and "action" in options and options["action"] == "disable"):
            print("disabling breakpoint")
            self.disable_breakpoint(edit)
        else:
            self.toggle_breakpoint(edit)

    def toggle_breakpoint(self, edit, *condition):
        viewId = str(self.view.id())

        print("----------------")

        for s in self.view.sel():

            exists = False

            #find the line that this selection is on
            line = self.view.line(s)
            lineNum = self.view.rowcol(line.a)[0] + 1

            #check if breakpoint is already stored and enabled
            for b in self.breakpoints[viewId]:
                if self.breakpoints[viewId][b].lineNum == lineNum and self.breakpoints[viewId][b].enabled is True:
                    print("breakpoint for line %i already exists" % lineNum)
                    self.remove_breakpoint(edit, self.breakpoints[viewId][b])
                    exists = True
                    break

            #create a new Breakpoint
            if not exists or condition:
                print("creating new breakpoint for line %i" % lineNum)
                breakpoint = Breakpoint()
                breakpoint.lineNum = lineNum
                breakpoint.lineContent = self.view.substr(line)
                breakpoint.enabled = True
                breakpoint.scope = "keyword"
                if condition:
                    breakpoint.debugger = " if(%s){ debugger; }" % condition[0]
                    breakpoint.scope = "string"
                    print("breakpoint.debugger = %s" % breakpoint.debugger)
                else:
                    breakpoint.debugger = " debugger;"
                self.add_breakpoint(edit, breakpoint)

    def remove_breakpoint(self, edit, breakpoint):
        viewId = str(self.view.id())
        line = self.view.line(self.view.text_point(breakpoint.lineNum-1, 0))

        print("toggling off breakpoint at line %i" % breakpoint.lineNum)
        #delete the debugger statement
        dedebugged = self.view.substr(line)
        print("this debug statement is %s" % breakpoint.debugger)
        print("this line is '%s'" % dedebugged)
        dedebugged = re.sub(r'%s' % re.escape(breakpoint.debugger), '', dedebugged)
        self.view.replace(edit, line, dedebugged)
        #clear the region
        self.view.erase_regions(breakpoint.id)
        #remove from breakpoints registry
        del self.breakpoints[viewId][str(breakpoint.lineNum)]
        #TODO - prevent the cursor from moving when removing breakpoint
        return

    #TODO - make this work...
    def disable_breakpoint(self, edit, breakpoint):
        viewId = str(self.view.id())
        line = self.view.line(self.view.text_point(breakpoint.lineNum-1, 0))

        print("disabling off breakpoint at line %i" % breakpoint.lineNum)
        #delete the debugger statement
        dedebugged = self.view.substr(line)
        print("this debug statement is %s" % breakpoint.debugger)
        print("this line is '%s'" % dedebugged)
        dedebugged = re.sub(r'%s' % re.escape(breakpoint.debugger), '', dedebugged)
        self.view.replace(edit, line, dedebugged)

        breakpoint.enable = False
        #redraw region as disabled
        self.view.add_regions(breakpoint.id, [line], "comment", "circle", sublime.HIDDEN | sublime.PERSISTENT)

    def add_breakpoint(self, edit, breakpoint):
        print("adding breakpoint for line %i" % breakpoint.lineNum)
        viewId = str(self.view.id())
        line = self.view.line(self.view.text_point(breakpoint.lineNum-1, 0))

        #store the breakpoint
        self.breakpoints[viewId][str(breakpoint.lineNum)] = breakpoint
        #place a marker at the specified line
        self.view.add_regions(breakpoint.id, [line], breakpoint.scope, "circle", sublime.HIDDEN | sublime.PERSISTENT)

        lineContent = self.view.substr(line)

        # grab the last non whitespace character in this line
        for match in re.finditer(r'\S', lineContent):
            pass

        #TODO - if this is a comment, make sure the semicolon adding rule accounts for that
        #TODO - when adding conditional to an existing breakpoint, double check semicolon
        # if the last character isnt a semicolon, add one
        if match.group(0) != ";":
            breakpoint.debugger = ";%s" % breakpoint.debugger
            print("last char is %s, adding semicolon" % match.group(0))

        #if this line contains a comment, place the breakpoint before the comment
        commentMatch = re.search(r'\/\/', lineContent)
        if commentMatch:
            #BUG - if comment is the beginning of the line, dont place debug statement on previous line!
            self.view.insert(edit, line.a + commentMatch.start(0)-1, breakpoint.debugger)
            print("this line contains a comment. adding statement ahead of comment")
        else:
            self.view.insert(edit, line.b, breakpoint.debugger)

    def clear_all(self, edit):
        viewId = str(self.view.id())

        for b in self.breakpoints[viewId]:
            self.remove_breakpoint(edit, self.breakpoints[viewId][b])

    def disable_all(self, edit):
        viewId = str(self.view.id())

        for b in self.breakpoints[viewId]:
            self.disable_breakpoint(edit, self.breakpoints[viewId][b])


class ConditionalBreakpoint(sublime_plugin.WindowCommand):
    def run(self):
        self.window.show_input_panel("Enter Condition:", "", self.on_done, None, None)

    def on_done(self, text):
        self.window.active_view().run_command("debuggify", {"condition": text})


class Breakpoint():

    def __init__(self):
        self.id = str(uuid.uuid4())


class DocUpdate(sublime_plugin.EventListener):

    numLines = {}

    #TODO - track insert/delete line actions instead of every modify
    #       backspace, del, cut, paste, enter, duplicate, undo, redo
    #TODO - consider using a regexp for breakpoint.debugger instead of storing it?
    def on_modified_async(self, view):
        viewId = str(view.id())

        if not viewId in self.numLines:
            self.numLines[viewId] = view.rowcol(view.size())[0] + 1

        #determine how many lines are in this view
        currNumLines = view.rowcol(view.size())[0] + 1
        # if it doesnt match numLines, evaluate where the lines were inserted/removed
        if currNumLines != self.numLines[viewId]:
            added = currNumLines - self.numLines[viewId]
            print("omg %i lines added!" % added)
            #use the cursor position to guess where the lines were inserted/removed
            #NOTE - this only supports single cursor operations
            cursorLine = view.rowcol(view.sel()[0].a)[0] + 1
            #TODO - once breakpoint.lineContent is being tracked, verify that the newly
            #       breakpointed line is the correct one. also use that to improve
            #       guesses for line insertion/removal

            #if there are any breakpoints for this view
            if viewId in Debuggify.breakpoints:
                newBreakpoints = {}

                test = ""
                #any breakpoint with a lineNum > cursorLine should be updated
                for b in Debuggify.breakpoints[viewId]:
                    bInt = int(b)
                    bOffsetInt = bInt + added
                    bOffsetStr = str(bOffsetInt)
                    if bInt > cursorLine-2:
                        newBreakpoints[bOffsetStr] = Debuggify.breakpoints[viewId][b]
                        newBreakpoints[bOffsetStr].lineNum = bOffsetInt
                        newBreakpoints[bOffsetStr].line = view.line(view.text_point(bOffsetInt-1, 0))
                        print("moving %i to %i" % (bInt, bOffsetInt))
                        print("line is %s" % newBreakpoints[bOffsetStr].line)
                    else:
                        newBreakpoints[b] = Debuggify.breakpoints[viewId][b]

                #update the global breakpoint list with the new one
                Debuggify.breakpoints[viewId] = newBreakpoints

            #update new number of lines
            self.numLines[viewId] = currNumLines

    def on_load(self, view):
        #TODO - only run this on js or html files?
        viewId = str(view.id())
        print("checking for existing debugger statments")

        #scan the document for debugger;
        results = view.find_all("debugger;")
        if results:
            allRegions = []
            print("debugger statements found!")
            view.sel().clear()
            for r in results:
                #TODO - prolly a smarter way to do it than this
                allRegions.append(sublime.Region(r.a, r.a))

            view.sel().add_all(allRegions)
            #TODO - dont add new debugger statement to each line
            view.run_command("debuggify")
